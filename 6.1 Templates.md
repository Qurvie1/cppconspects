мы хотим для любого типа T определить что-то
typename = class по сути

То есть например `swap` работает одинаково для всех классов - мы просто обмениваем 
```cpp
template <typename T>
void swap(T& x, T& y) {
	T t = x;
	x = y;
	y = t;
}
```

можно объявлять шаблонные классы

а можно даже шаблонный юзинг
```cpp
template <typename T>
using mymap = std::map<T, T, std::greater<T>>;
```
и по сути, можно сделать
mymap<T*> m; - и это будет то же самое

шаблоны - это **кодогенерация** (паттерн, по которому делается код)

допустим, что мы делаем:
```cpp
int a = 0;
long long b = 1;
swap(a, b)
```
по сути, компилятор не понимает какую версию взять, в этом и вся проблема, потому что он понимает какой код сгенерировать ещё до этой стадии.
[[6.2 Template overloading]]
