Наследование - важный столб ООП

некоторые типы - частный случай других типов

жизненный:
животное - подтип млекопитающее - подтип хищники - подтип - кошачьи и так далее
ы

вот есть базовый класс
```cpp
struct Base {
	int x;
	void f() {}
};
```

: - означает наследник
```cpp
struct Derived: Base {
	int y;
	void g() {}
};

int main() {
	Derived d;
	// у него есть как x, так и y, как f, так и g
}
```

можно написать
```cpp
protected:
	int x;
public:
	void f();
```
**ПРО ЧЛЕНЫ КЛАССА**
протектед - доступен всем другим членам класса, наследникам и друзьям
private - члены класса недоступны для наследников

нужно отличать *доступны* и *видны* - обе функции видны, но лишь одна доступна
сначала компилятор ищет в области видимости, потом уже применяет функцию

отличие структуры от класса - по умолчанию наследники тоже публичные или приватные
**ПРО НАСЛЕДОВАНИЕ**

публичный родитель - любая внешная функция знает о том, что Base - родитель

Derived: private Base - только я сам и мои друзья знают, что я - наследник, но даже наследники мои не знают

тогда d.x - CE - нарушение приватности, так как никто не знает, что я наследник Base (родительская часть ЗАКРЫТА)
Derived: protected Base - ещё наследники знают
```cpp
struct Granny {
	friend int main();
	int x;
	void f() {}
};

struct Mom: protected Granny {
	int y;
	void g() {
		std::cout << x
	}
};

struct Son: Mom {
	int z;
	void h() {
		std::cout << x;
	}
};

Son s;
s.x // - CE - так как из внешней функции не видно
s.h() // - можно! так как у сына есть доступ
```
теперь как работает дружба
friend в бабушке не спасает, так как friend не снимает ограничения матери

теперь
пусть
```cpp
void h(Granny& g) {
	std::cout << g.x;
}
```
тоже ошибка, так как сын не друг granny
и мы не наследник (потому что это другая бабушка)
[[4.2 Visibility]]
