В чём смысл листа - вставление и удаление из середины

есть `insert (iterator, value)`

Тут как раз нам и нужны [[8.2 Iterators|итераторы]], потому что здесь нет индексации

`erase (iterator)` (можно передавать начальный и конечный итератор - O(от разности диапазонов)

Итераторы bidirectional (инкремент + декремент)

`push/pop back/front`

`size`

Всё за O(1)

Как реализовать?
```cpp

template <class T>

class list {

	struct Node {

		T value;

		Node* prev;

		Node* next;

	};

	Node* head;

	Node* tail;

	size_t sz;

};
```

в чём трабл - у нас есть l.end() и его декремент по определению это последний элемент, но как это реализовать, на что его тыкать?

так что делать то по итогу - нужно взять **sentinel** (и он будет связан с хвостом и головой) и на него будет указывает end

а `iterator` - это просто `Node*`

в чём проблема - много операторов new

можно взять структуру `BaseNode` и наследника `Node`, содержащего T

И хранить BaseNode, а не указатель, тогда

`list() : fakeNode { this, this }, sz(0) {}`

При этом мы не хотим что-то аллоцировать, если лист пустой, поэтому если нет элементов

Поэтому можно просто хранить `BaseNode fakeNode { &fakeNode; &fakeNode }`

Поле класса хранит указатели на это же самое поле, именно поэтому нельзя memcpy в векторе для реаллока

Есть `sort()`, `merge()`, `splice()` - типа взять кусок одного листа, вклеить в другой

нет рандом аксесс итератора, поэтому можно пользоваться мердж сортом

Есть метод merge - сливает

**forward list** - нет метода size, forward iterator, есть только insert after

обычный инсерт работает по итератору, например, в начало типа insert(l.begin())

а insert after понятно, потому что нет информации о прошлом

**std::map**

можно делать вставку по ключу

`pair <iterator, bool> insert (const Pair<Key,Value>&)` - если пытаемся вставить ключ, но он уже есть, то просто вернётся iterator куда вставили, а bool false

`erase(Key)`, есть `erase(Iterator)`

`operator[](key)`

`find(key)` - возвращает итератор

всё работает за O(lgn) - гарантированно (не аморт)

делается через красно-чёрное дерево или авл-дерево

красно-чёрное дерево лучше, поскольку поменьше в среднем поворотов (константное)

нет `[]` от `const std::map`, потому что если не находит, то не кидает исключение, а происходит создание (изменение константы)

`size_t count` (подсчёт числа ключей)

как лучше находить и присваивать? поиск возвращает итератор и итератору мы присваиваем
```cpp

template<typename Key, typename Value>

class map {

	struct Node {

		pair <Key, Value> kv;

		Node* left;

		Node* right;

		Node* parent; //(важно хранить, потому что хотим ходить итераторами)

		bool red;
	}
```

мы просто подвесим всё дерево слева за фейк ноду

на самом деле Node выравнены по 8 и в последнем бите родителя можно это хранить

почему именно пару - хотим по итератору получать и то, и то

важно - там лежит `const Key`

тогда можно

`auto it = m.find(5);`

`it→first = 0`

это бы компилировалось и ломалось бы красно-чёрное дерево

`typename Compare = std::less<key>`

что храним

`Compare comp;`

`size_t sz;`

`BaseNode* fakeNode;`

`BaseNode* begin;`

как обеспечивается безопасность исключений?

проблема в чём, компаратор кидает исключения

в красно-чёрном дереве - никогда не делаются повороты после сравнения

поэтому если кидается исключение то ничего не испортили