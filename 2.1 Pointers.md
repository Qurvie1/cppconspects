Указатель
У каждой переменной есть какой-то адрес в памяти, тогда можно спросить номер ячейки, где лежит эта переменная.
С помощью оператора & можно получить адрес ячейки в памяти
&x (&: T -> T*) (addres)
Через звёздочку (dereference)
Тип &x = int*
К указателю можно прибавлять инты
Получится новой указатель, к этому численному значению (В T* добавляется sizeof(T) * int (который прибавляем))
&v[0] - постфикс сначала (сначала v[0], потом &v)
std::cout << *++p (получим следующий элемент массива по сути)
2 указателя - это по сути числа, поэтому когда мы берём разность двух указателей, то мы вычитаем 1 из другого и делим на 4
Интересный факт - указатель занимает 8 байт на 64-битной, 4 байта на 32
унарная звёздочка возвращает lvalue
Интересный пример:
int a = 1;
указатель на a
{
int b = 2;
указатель на a = b
}
Вопрос - чему равен указатель? Поинт в том, что мы заставили p указывать на область памяти b, но её время жизни как бы закончилось, но память то осталась, поэтому выведется 2, но вообще UB
Память может переиспользоваться под переменные, которые когда-то были в локальной, потом убились.
Мы не можем сравнить указатели разных типов (сделано в целях безопасности)
Есть такой весёлый тип - void* - ему можно отдать указатель на любой тип. Можно только скопировать туда что-то или взять оттуда, с воид звёздочка ничего нельзя сделать другого.
Есть такое слово nullptr - это типа 0 в мире указателей.
Смысл указателей - передача их в функции по сути.
[[2.2 Kind of memory]]
