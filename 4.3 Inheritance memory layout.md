```cpp
struct Base {
	int x;
	Base(int x): x(x) {}
}

struct Derived: Base {
	double y;
	Derived(double y): Base(0), y(y) {} // конструктор в конструкторе
}
```
`sizeof(Derived) = 16;`

если поле пустое, то структура весит 1

**EBO Empty Base Optimization**
на самом деле это 8

Derived d = 3.14 - CE (сначала создаётся объект родителя, потом наследник, поэтому непонятно чем инициализировать по умолчанию)

То есть сначала создаются поля родителя, потом сам родитель, потом создаются поля наследника и сам наследник

конструктор - сначала инициализируется родитель, потом сын, деструкторы в обратном направлении работает.

Поэтому очень плохо, если у нас много конструкторов, то нужно всё это писать (а писать там много), то есть все 20 конструкторов.

using Base::Base - юзинг конструктора (это нужно, чтоб постоянно не писать какой-то конструктор)
но конструкторы копирования не наследуются (иначе появляется неявный каст родителя к наследнику)

когда мы разрушаем, то сначала работает деструктор наследника, потом уничтожаются поля наследника, потом отрабатывает деструктор родителя, потом уничтожаются поля родителя.

опять же, если мы делаем конструктор наследника, то нужно сначала объяснить как 
создавать родителя:
```cpp
Base(int x): x(x)
Derived(int y): Base(0), y(y) //- то есть сначала мы инициализируем базу, а потом уже всё таки derived
```
[[4.4 Type conversion in inheritance]]
