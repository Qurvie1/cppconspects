если в классе есть хотя бы одна виртуальная функция, то `sizeof(Base) == 8` (из-за поинтера)

в vtable хранятся как виртуальные предки, так и виртуальные методы.

если у нас есть виртуальная функция, то у объекта должен быть указатель на vtable - таблицу виртуальных функций, которая хранится в статической памяти 1 на тип, где перечислены адреса функций этого типа.

там хранятся как виртуальные предки, так и методы.
```cpp
struct Base {
	virtual int f() {}
	void h() {};
	int x;
};
```
`vtable Base`

что там хранится: адрес `Base::f` + адрес Base `typeinfo` (то есть адрес функции и `typeinfo`)
ptr -> vtable

`Base typeinfo` - вся инфа о типе

Base vtable:
`ptr, x, выравнивание`
```cpp
struct Derived: Base {
	void f() override {}
	virtual void g();
	int y;
};
```

пусть есть f - виртуальная, h - невиртуальная, x - метод
`sizeof Base == 16` - очевидно (из-за выравнивания)

объект Derived
ptr, x, y

по сути, количество методов не влияет на память, но вот виртуальные функции влияют

но как выглядит Derived vtable:
`&Derived typeinfo, &Derived::f, &Derived::g`

как работает вызов виртуальной функции?
Derived d;
Base& b = d
b.f()

Сначала компилятор видит, что функция виртуальная, поэтому просто так её не вызвать.
Поэтому он идёт в vtable.
Допустим, мы запускаемся действительно от Base.
Мы идём по поинтеру в таблицу, дальше, компилятор знает, что эта первая по счёту из виртуальных функций объекта и он запускает эту функцию по поинтеру, который там лежит

Ну и динамик каст по сути также работает, то есть в зависимости от того че написано в `typeinfo`.

сначала мы идём по поинтеру, с которого начинается наш объект и чё там вообще.
Тогда компилятор знает, что мы Base и он запускает функцию по указателю

мы получаем `vtable base`, но потом разыменовывается указатель в base и мы идём уже в derived
ну и динамик каст работает так же, только смотрит на typeinfo постоянно

Granny
Mom
Son
в Mom `virtual void f() {}`

`void f() override`

как выглядит Son

ptr (потом бабушка) g, m, s

что происходит, когда делаем каст от сына к бабушке, то если потом делать обратно, то будут проблема, так как бабушка невиртуальная

[[5.6 Memory layout of polymorphic objects of multiple inheritance]]
