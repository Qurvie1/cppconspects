определим 
у S какой-то метод:
```cpp
struct S {
	void f {
	}
}
```
`const S s;`
`s.f();`
Это CE, так нельзя, проблема в том, что по умолчанию методы, которые мы определяем в классах они считаются неконстантными, то есть их нельзя вызывать методы, которые должны присутствовать у константных объектов
поэтому нужно писать

`void f const {}`

то есть у констатных объектов должны быть константные методы
так происходит, потому что неявно в f() мы подставляем типа self и проблема в том, что мы подставляем константу, вместо самого объекта, если так пишем
можно вызывать перегрузку по константности метода, очевидно, как она будет работать

вот мы хотим реализовать `operator[]`

```cpp
char& operator[] (size_t index) {
	return arr[index];
} 
```
но в чём проблема - если у нас строка константная, то это не будет работать, потому что мы от констатного объекта вызываем неконстантный метод
поэтому надо ещё сделать

```cpp
const char& operator[] (size_t index) const {
	return arr[index];
} 
```

`mutable` - иногда в константном методе мы хотим поменять поле
если `mutable int x = 1;`
тогда x уже никогда не константный
когда это полезно? когда мы например хотим увеличивать счётчик, когда дебажим

иногда нам нужно, чтоб метод относился не к объекту класса, а ко всему классу целиком, например, нам иногда хочется выполнить разворот (допустим, когда мы биг интежер пишем)
и он не относится к конкретному объекту, а к классу в целом

`static` метод работают как функции, но объявленные в теле класса по сути
то есть
```cpp
struct S {
	static void f ()
}

S::f();
```

стандарт C++ запрещает делать static int x = 1 в классах (нужно const)

Singleton - обращение к базе данных, типа мы хотим создать объект, если его нет или выдать его, если он уже есть

explicit - явный, неприкрытый.

позволяет делать разными типами (запрещать неявную конверсию, типа у нас есть id, group_id, chat_Id, но они могут конверситься в int) explicit это запрещает
```cpp
struct Latitude {
double value
explicit Latitude(double value) : value(value);
}
```
строгая типизация позволяет типа не путать широту с долготой
то есть например мы куда-то передаем точки и случайно написали сначала широту, а потом долготу, то из-за того, что мы явно определили конструктор, тогда при передаче такой не будет приведения типа к даблу, а они останутся так и будут проблемы

оператор приведения типа (оператор, куда приводим)
```cpp
explicit operator double() const {
	return value;
}
```
то есть мы разрешили приведение от Latitude к даблу, но при этом сделали, чтоб нельзя было неявно конвертировать, а чтоб сделать явно нужно сделать static cast

даже к булю нужно писать явный каст 

чтоб определить литеральный суффикс нужен `operator""`

[[3.6 Operator overloading]]

