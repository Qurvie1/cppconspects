можно пометить функцию, чтоб она не кидала исключений:
(`noexcept`-квалификатор)

```cpp
void f() noexcept {
}
```

можно написать:
```cpp
void f() noexcept try {
} catch (…) {
}
```

можно например noexcept ссылки
`noexcept` - условный квалификатор
`void f() noexcept(std::is_reference_v<T>)`

есть ещё оператор `noexcept(g)` - который проверяет является ли функция noexcept

`void f() noexcept(noexcept(g<T>()))` - вызов noexcept, только если функция g такая
(то есть снаружи - условный квалификатор, а внутри оператор)

реализуем push_back в векторе

reserve:

писать

`T* newarr = new T[newcap]` - неправильно:

тут проблема в том, что мы создаём newcap объектов T, но вызываем конструктор по умолчанию, которого может и не быть

поэтому нам не нужно создавать объекты, нам нужно лишь в них выделить память

поэтому `T* newarr = reinterpret_cast<T*>(new char[newcap * sizeof(T)])` - то есть мы просто выделяем память на эти объекты и заставляем их читать как T*

далее мы типа перекопируем, но нельзя писать:

`newarr[i] = arr_[i]` - потому что нет T, в newarr чистые байты

`new(newarr + i) T(arr_[i])` - **placement new** - типа мы создаём новые байты по адресу, который мы передаём

и мы не можем удалить arr как массив T, потому что он изначально не был массивом T, а как просто чистые байты

поэтому нужно сделать

`delete[] reinterpret_cast<char>(arr_);`

`arr_ + index→~T()` - вызываем деструкторы руками

Гарантии безопасности:

1) No-throw guarantee - обязательно операции будут удачными, если же что-то и происходит, то оно будет поймано и исправлено
2) Strong exception safety - не будет эффектов
3) Basic exception safety - эффекты будут, но всё будет валидно
4) No exception safety

