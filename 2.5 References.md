У нас есть какая то переменная int x = 5
в чём смысл, если я мог передать её в функцию, менял там его как-то и получал уже нормальный х, а не копию
int& y = x;
f(x);
Любое создание элемента - это копирование, если нам нужно создать новый объект равный старому, то есть ссылки.
Поскольку в плюсах нет сборщика мусора, то мы не можем сделать вот такую ссылку как в питоне, то есть мы всегда создаём новый объект
int x = 5;
int& y = x;
нужно понимать - что это одинаковые вещи, просто по разному названные
Интересно, если смотреть f(x) и f(y) - то это одинаковые функции на самом деле
Ссылку нужно обязательно определить, а ещё ссылка должна быть проинициализирована lvalue
int t = g(x)
lvalue-to-rvalue conversion -
int x = y - что мы делаем по сути, мы считываем значение из ячейки y (то есть конвертируем lvalue в rvalue), а потом уже присваиваем.

Битая ссылка:
int& f(int& x) {
int y = ++x;
return y;
}
int x = 0;
int& y = f(x);
создаём внутри функции переменную, её возвращаем, а потом объявляем ссылку - проблема
если статик или глобальный x, то всё окей.

int& g() {
int* p = new int(1);
return *p
}

int& x = g();
delete &x;
это вполне корректный код, при этом если сделать int x просто, то это ошибка
Нельзя делать int&*