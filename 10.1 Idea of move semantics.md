
```cpp
vector<string> v;
v.push_back(”abc”);
```
создается временный объект стринга и привязывается константная ссылка

далее placement new

`new(…) T(value)` - создаётся второй стринг тут, временный стринг уничтожился

то есть мы 2 раза копируем по сути

emplace_back - принимает объекты и создаёт на месте, снова будем создавать, если делать вектор векторов

```cpp
struct S {

  string data;

  S(const string& str) : data(str) {};

}
```

тогда мы хотим мувать объекты

мы на самом деле хотим, чтоб мы могли собрать данные и переместить (то есть перенести поинтер)

вводим `string&&`
```cpp
string(string&& other) : arr(other.arr), sz(other.sz), cap(other.cap) {

  other.arr = nullptr;

  other.size = other.cap = 0
}
```
 это мы делаем, чтоб оставить его валидным, то есть мы из него что-то переместили, но он остаётся таким

```cpp
string& operator=(String&& other) {
	delete[] arr;
	arr = other.arr;
	s = other.sz;
	other.sz = 0;
	cap = other.cap;
	other.cap = 0;
}
```
просто забираем поля

теперь вопрос: а когда вызывается этот конструктор?

**rule of five**:

копи конструктор, деструктор, копи ассигмент оператор, мув конструктор, мув ассигмент оператор

дефолтный мув конструктора - просто перемещение, для интов и булей копирование, а для нетривиальных классов - вызывает мув конструкторы всех полей