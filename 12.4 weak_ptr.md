В чём идея - вот мы пишем дерево на [[12.2 Shared_ptr|shared_ptr]]. В чём проблема - на каждую ноду указывают её дети и как бы компилятор считает, что пока на ноду что-то указывает, то её 
нельзя удалять.

И поэтому, если у нас удаляется корень дерева (а мы дерево храним как корень), то всё остальное не удаляется (поскольку остаются циклические зависимости между нодами (у родителей есть указатель на ребёнка, а у ребёнка указатель на родителя) - и в итоге мы не можем удалить родителя, так как на него ссылается ребёнок и наоборот)

и поэтому вводится weak_ptr - поинтер, который не учитывается при подсчёте ссылок

тогда в дереве мы от родителей к ребёнку делаем shared_ptr, а от ребёнка к родителю - weak_ptr

и поэтому, мы можем удалить родителя, так как на него указывает weak_ptr (и можно удалять от корня тип).

интересный факт, что weak_ptr нельзя разыменовать, а можно получить shared_ptr на объект с помощью метода `.lock()`

пока есть какой-то shared_ptr, указывающий на какой-то объект, то weak_ptr ещё валиден.
