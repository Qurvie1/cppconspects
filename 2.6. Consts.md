[[2.5 References]]
Вот есть int x = 5
можно const int c = 2
const - модификатор типа, который делает его константным
Константы - это другой тип, у которого часть операций исходного типа отсутствует.
Типа целые числа и натуральные числа
В натуральных числах нельзя вычитать
Можно в целом делать z = y, даже если const int y
Теперь указатели
Пусть int* p = &x
const int* pc = p - тут константа - инт, а указатель - нет
Тут кстати произошло преобразование
int* -> const int*
В обратную сторону нельзя делать кстати

int* const cp = p - тут указатель константный
То есть pc можно поменять, но что под им - нельзя
В cp нельзя поменять сам указатель
Причём, даже если pc переставить, то всё равно будет нельзя, почему так:
потому что pc указывает на const int, то есть при разыменовании будет возвращаться const int
Хотя кстати, если есть указатель на константный инт, то есть const int* p, то можно поменять х под ним
int x = 5
const int* p = &x
++x
std::cout << p*
Будет выведено 6
const int* - право только на чтение
int* право на запись и чтение
Теперь константные ссылки
int x = 5
const int& r = x
Опять же r - это то же самое что и x, но мы лишаемся части прав
то есть
++r - нельзя
++x - можно
int& const - CE - так как ссылка всегда константная 
Константы нужно сразу инициализировать
Как мы хотим закидывать в функцию переменные (скажем строку)
4 варианта:
const string (никогда)
string
string&
const string&
Если не хотим менять, то казалось бы хотели взять const string&
И тут есть прикол в том, что если мы подаём rvalue, то const string& = rvalue - можно (то есть передать в функцию rvalue)
Но если просто ссылка - нельзя
const string& c = "aaaaaa"
Что происходит когда мы так делаем
в data кладётся литерал "aaaaaaa"
на стеке создаётся строка, имеющая размер, capacity и ptr, который указывает в динамическую память
А при создании, строка выделять new как раз память 
А как он удаляется, на самом деле создаётся исключение (lifetime expansion)
Чаще всего пишем const string&
Но если мы кладём в функцию инт, чар или чет маленькое, то размыменование укзаателя (что происходит при вводе ссылок), то мы теряем эффективность.
Но почему просто не сделать это для всех ссылок?
Есть глубокая причина, что было бы плохо
int x = 0;
g(x);
g(size_t& y) {
++y
}
std::cout << x;
ссылка может привязаться только к тому типу, который передаётся, но поскольку там size_t, то мы передаём int, а создаётся копия int, которая size_t и мы меняем как бы копию
const string&
string&
это разные вещи
Lifetime expansion - работает только если мы иницилиазируем переменную, а не возвращаем её из функции.
Интересно, что если
int* p = new int(0)
int** pp = &p
const int** cpp = pp - так нельзя, то есть нельзя врубать константность более чем на 1 уровнь
пример, пусть разрешено:
const char x = 'a'
char* p = nullptr
const char** q = &p 
nonconst ptr -> noncost ptr -> const char
q* = &x - можем, указатель не константный (то есть мы поменяли указатель p)
p -> x
но p - это неконстантный указатель
то есть можно сделать
p* = 'b' - то есть мы поменяли константу!!
[[2.7 Type conversion]]

