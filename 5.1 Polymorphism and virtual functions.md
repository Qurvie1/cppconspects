```cpp
struct Base {
	void f() {
		std::cout << 1
	}
};

struct Derived: Base {
	void f() {
		std::cout << 2
	}
};

int main() {
	Derived d;
	Base& b = d;
	b.f()
	//будет 1
}
```

но мы хотим 2 по сути, потому что идейно мы хотим выбирать всё таки частные случаи, то есть мы хотим работать в зависимости от частности случая

как нам добиться, чтоб выводилось 2 вне зависимости от инициализации?

сделаем функцию в Base как
```cpp
virtual void f() {
}
```

идейно - это функция, которую даже если мы вызываем как ссылку от родителя, она всё равно работает для наследника

тип у которого есть хотя бы одна виртуальная функция называется полиморфным (или если есть хотя бы одна унаследованная) и даже унаследованные тоже становятся виртуальными (ну типа Derived унаследовал виртуальную функцию, )


окей, допустим сделаем в дерайвде
```cpp
int* p = new int(0);
	~Derived() {
	delete p;
}

Base* b = new Derived();
delete b;
```
в чём проблема? когда мы удаляем b мы удаляем объект класса b, в частности, вызываем деструктор от Base, но создаётся же ещё указатель в Derived, который мы не удаляем, поэтому деструктор тоже должен быть виртуальным!

что делает оператор delete на самом деле?
вызывает деструктор и чистит память, а new высвобождает память и вызывает конструктор

как починить?
нужно сделать virtual ~Base() = default;
[[5.2 Virtual examples]]
