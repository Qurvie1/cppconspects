Есть Base и Derived
```cpp
struct Base {
	int x;
}

struct Derived: Base {
	int y = 2;
}
//если у нас есть функция, которая применяет Base, то можно подсунуть наследника, вместо родителя.

void f(Base& b) {
std::cout << b.x;
}
```
по значению тоже (то есть не по ссылке)

тогда произойдёт слайсинг (*срезка*): будет неявно сгенерирован консруктор Base от Derived (то есть когда мы засунем Derived, то мы оттуда типа вытащим объект Base (создадим его копию)).

Если у `Base` есть нетривиальный конструктор копирования, то он будет вызван (очевидно).

cast
Derived -> Base:
implicit, static, reinterpret можно везде, кроме reinterpret в копии (ну тут просто теория, так как мы туда ссылку передаём)
при этом при приватном наследовании везде наоборот CE, кроме reinterpret (и то, потому что реинтерпрет касту вообще похуй что происходит)

Base -> Derived - можно только статик каст и реинтерпрет каст (static и reinterpet)
как и приватное Derived -> Base

[[4.5 Multiple inheritance]]

