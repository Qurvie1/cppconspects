set == map, только ключи

`multimap` - тоже нет `[]`

храним массивчик, размера N

хотим ключи поступаемые похэшировать

и если хэш функция хорошо, то массив будет +- случайным, тогда мы редко попадём в одну и ту же ячейку.

тогда в среднем всё за О(1) (expected ≠ амортизированно).

если 2 ключа в одну ячейку попали, то тут есть 2 варианта:

1. метод открытой адресации - просто идём в следующую (самая простая функция), но усложняется поиск

лучше брать размер простой, потому что когда мы будем брать по модулю, то всё кардинально сложнее будет

есть хэш кукушки - 2 хэш функции, если хотя бы в одной не лежит, то кладём туда

2. метод цепочек - храним связный список
```cpp
vector <forward_list<Node>> array;

Node {

pair <const Key, Value> kv;
```


`insert` - проходим, если есть, то вставка не удалась, если нет, то идём

`erase` - удаляем по итератору

но всё плохо - нужно иметь итерироваться, то есть обходить контейнер за O(n), а не за число бакетов в контейнере

load_factor - отношение лежащих ключей к N

поэтому сделаем 1 большой форвард лист

теперь в ячейках храним указатели на форвард лист (на бакеты)

но как понять когда мы вышли из бакета (мы будем хранить хэш в нодах)

как делать инсерт?

идём по бакету, если есть, то всё хорошо, если нет, то добавим в конец (insert after), если был пусток бакет, то в начало списка

как делать erase?

в чём основная проблема - для предыдущей ячейки (перед удаляемой) переставить поинтер на следующую (которую удаляем)

2 пути: сделать двусвязный список, тогда всё хорошо

2-й путь:

как сделано? давайте хранить указатель на конец предшествующего

а указатель на начало списка - это указатель на фейковую вершину

как файд? идём по указателю - переходим и смотрим, пока не изменится хэш

инсерт? если в конец или начало, то можем обновить, но как сделать, если бакета не было?

тот, кто указывал на начало (на фейк вершину), должен теперь указывать на нашу вершину, а наша вершина - на начало списка

тогда мы берём начало списка, берём хэш, по нему идём в таблицу, понимаем, какая ячейка соответствовала, убираем указатель, и теперь этот указатель указывает на нашу вершину

эрейз? теперь трабл в конце бакета

допустим, вот мы добавили

мы узнаём, кто предыдущий, потому что мы берём указатель в векторе, ячейка указывала на фейковую ноду (она предыдущая), забываем указатель, проходим на следующую ноду, смотрим по хэшу, какой указатель указывает, тогда этот поинтер ставим на предыдущую ноду для удаляемой ноды, ну ии всё

как делать рехэш? - это просто последовательный эрейз из старого форвард листа и делаем инсерт в новый

прям руками вставляем, сохраняя пару, поэтому не инвалидируются ссылки и указатели

но итераторы можно разыменовать, но инкремент не работает особо

std::hash для своего типа мы можем доопределить

exception safety - мы ничего не делаем в рехэше, потому что