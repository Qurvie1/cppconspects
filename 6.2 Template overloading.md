```cpp
template <typename T>
void f(T x) {}

void f(int x) {}

int main() {
	int x = 0;
	f(x);
}
```

**частное - лучше общего**.

это логично, что выберется вторая, потому что мы, как компилятор, не хотим делать новую копию функции (то есть более частное взять)

**точное соответствие лучше чем какой-то каст**

```cpp
template <typename T>
void f(T x) {}

void f(long long x) {}

int main() {
	int x = 0;
	f(x);
}
```

он сгенерировал первую версию, потому что он может выбрать точное соответствие 

если мы явно указываем шаблонные параметры, то он выберет шаблонную версию

можно делать аргументы по умолчанию

```cpp
//пусть есть 
f(int x)
f(int& x)
```
что вызовется? - нет разницы, поэтому фактически, это работает одинаково, то есть ссылки понижаются.
но если вывести f(1), то будет 2

[[6.3 Template specialization]]
