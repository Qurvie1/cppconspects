сstyle_cast
static_cast
reinterpret_cast
dynamic_cast
const_cast
1) static_cast<к чему>(от чего) - выполнены все обычные преобразования, с самим x ничего не произвойдёт. Ещё полезная штука - приведение к указателю на воид любого указателя
2) reinterpret_cast - способ взять биты одной переменной и трактовать как биты другой переменной. Был long long, мы говорим, прочитай как будто там дабл. long long y = 1729
сделаем std::cout << reinterpret_cast<double&>(y)
обязательно приводим к ссылке. Почему к ссылке? Без ссылки типа создай новый дабл, несвязанный cо старым, а ссылкой мы смотрим на старый объект. То есть мы создаём новое название старому объекту через другой тип. В чём смысл, если он практически всегда даёт UB?
Нельзя читать переменные одного типа побитово как будто это другой тип.
Полезно, если в структуре1 у нас int, double и в другой int, double
он позволяет перекастовать что угодно к чему угодно, КРОМЕ констант. тут нужен const_cast
3) const_cast - отменяет константность 
const int c = 1
я захотел поменять число
опять же, каст делается к ссылке, потому что мы хотим по другому назвать уже имеющуюся переменную (то есть назвать её интом)
int& cc = const_cast<int&>(c)
cc = 7
std::cout << c << ' ' << cc - то UB
почему UB
в чём смысл const cast - может быть нам дали константую ссылку, но мы знаем, что под ней что-то, что не было констатной
вот допустим
void f(const int& c)
но вы знаете, что передаётся не константа, то так мы можем сделать
reinterpret_cast - плохое заклинание языка C++, const_cast - ещё хуже
так же можно снимать конст из под указателя
самое ужасное заклинание
4) cstyle_cast
Это типа double d = (double) x
Что он делает? он пытается быть конст_каст сначала, если нет, то он делает статик каст, проблема в том, что мы не можем точно понять, какой именно каст был сделан
5) dynamic_cast - секрет

[[2.8 Stadies of compilation]]
