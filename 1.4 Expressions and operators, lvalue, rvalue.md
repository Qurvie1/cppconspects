Statement - это либо declarations (только на глобальном уровне), expressions, control statements (это уже можно в локальном, это if, for, while)
; - граница инструкции, отделяет 1 стейтмент от другого
Операторы
&, <<, >>, %, /, +, -, *, ^, ||, <, >, 2 равно, с c++ 20 есть <=>
Интересный факт: && и || вычисляется лениво.
То есть если написать (v.size() >= 5 && v[4] == 1)
то ошибки не будет, поскольку сначала посчитается левое, а потом уже правое.
С точки зрения компилятора это будет работать так, но процессор может вычислять правую часть, хоть компилятор ему запретит.
Операторы присваивания:
Интересные приколы,
cout << (x = y) - вернётся ссылка на присвоенный x
(x = y) = z, после x = y возвращается ссылка на то что получилось (то есть на x)
это называется lvalue
результаты операторов присваивания - lvalue, других - rvalue.
Подразделение на лефт и райт в зависимости от того, можно ли им что-то присваивать, если да - lvalue, нет - rvalue;
Операторы присваивания - правоассоциативны.
то есть x = y = z то же самое, что x = (y = z) (сначала в х записывается y, а потом в x записывается z).
Операторы, возвращающие rvalue - левоассоциативные.
то есть x + y + z = (x + y) + z.
Если переопределить && то останется свойство ленивого вычисления.
Интересные операторы - инкремент и декремент.
++а - увеличение на 1 и возвращение того, что получилось (lvalue) (вернулась уже новая переменная)
a++ - увеличение на 1 и возвращение того, что было (это rvalue) (очевидно, потому что наша переменная уже увеличилась на 1, поэтому она настоящая - это a = a + 1, а мы возвращаем ту, которая была)
Инкрементировать можно только lvalue
++a++ что это? по стандарту, это ++(a++) - то есть ошибка (то есть сначала постфиксные)
a+++++b - как работает лексический парсер - он отсчитывает максимум + так, чтоб это было осмысленно (чтоб это было токеном - лексемой) (жадный лексический парсер)
то есть сначала будет a++ (2 плюса отщипнул), потом он отщипнёт ещё 2 плюса и будет ошибка
а вот ++++a можно 
И вот вроде как вычисляется ++a++, вроде лексический парсер должен заставлять ++, но дальше включается грамматика и она говорит, чтоб было сначала постфиксные, а потом префиксные.
Интересные операторы - тернарный. Как он работает? Берёт первый аргумент, кастует его к буль, потом считает второй (если истинно) (важно! - будет вычисляться лишь один результат, второй не будет).
Вид вэлью должен быть известен на этапе компиляции, поэтому нельзя чтоб 1 аргумент был rvalue, а другой - lvalue (если к этому что-то присваивать, просто он посчитает это rvalue.
Если для двух этих аргументов он не может определить тип - это CE (если их нельзя их скастовать).
f(b ? 1 : 0.5) - тип внутреннего выражения определяется на этапе компиляции и он становится флоатом.
Оператор запятая?
a, b вычисляет a, вычисляет b, потом возвращает b.
в функции - не оператор запятая, так как это не экспрешены (в функции - это декларейшены)
Другой оператор sizeof(a) - сколько байт в памяти занимает переменная.
sizeof(a) это не то же самое, что size()
Приоритет операторов:
::, постфиксные, префиксные, ->, потом арифметические, битовые сдвиги, потом логические операторы (>, <, хоры, прочее), далее присваивание.
Далее Order of evaluation - сами операнды и операторы необязательно вычисляются в таком порядке, то есть выводится != вычисляются)
Sequence before rules
В C++17 появилось, что сначала правой сайд эффект и вэлью компьютейшен, а потом уже левой, и потом уже сам оператор.
Инкремент - это 2 действия, вычисления значения (сайд эффект) и подстановка (вэлью компьютейшн).
Далее
[[1.5. Control statements]]

