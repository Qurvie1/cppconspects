`vector<int> v(10);`

`int* p = &v[5]`

`v.push_back(1);`

`cout << *p;`

Это UB

Нельзя модифицировать в вектор, после чего разыменовывать указатели на элементы до этого (инвалидация указателей), потому что вектор мог реаллоцироваться (то есть увеличиться capacity)

`пусть теперь int& p = &v[5]`

Это тоже UB (ссылка = указатель, поэтому битая ссылка).

Теперь переходим к deque, у него 2 отличия от вектора:

Нет инвалидации указателей

Как сделаем?

Заведём массив из указателей (указателей на Т) (`T**`)

То есть у нас есть большой массив за который подвязываются массивы `T*`.

СНАЧАЛА НЕТ НИЧЕГО

и когда мы хотим сделать push_back, поэтому мы берём массив СЫРОЙ ПАМЯТИ, засовываем 1 элемент и всё ещё там лежит сырая память

push_front - заполняем массив с конца

и нужно помнить всегда где начало, а где конец текущего дека.

как происходит реаллокация - мы просто создаём ещё массив, куда указываем

`std::stack`, `std::priority_queue`, `std::queue`

Обёртка над контейнерами.

Например, у `std::stack` параметры `template <typename T, typename = std::deque<T>`

Почему второй шаблонный аргумент это не `template <typename...> typename` - потому что не знаем что за шаблонные аргументы.