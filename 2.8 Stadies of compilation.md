что происходит, когда я пишу g++ 1_1.cpp - происходит целый конвеер операций.
есть 4 стадии
1) препроцессинг - обрабатываются директивы препроцессора (#include - берётся файл и копипастится в наш код целиком, то есть у нас фактически файл из 1000 строк, он заранее знает где искать <iostream&>, можно по кавычкам кстати, # if, # pragma), всё ещё 1_1.cpp
2) компиляция (берёт код на c++ превращает в код на ассемблере -> 1.s) - это сложная стадия и там их много
3) ассемблирование - assemble - сборщик, то есть он берёт код и собирает его (дословно), получается файл 1.o (то есть уже объектный файл, типа инструкции для процессора). 
5) линковка (занимается линкер - ) Когда вы заинклудили объявления от <iostream&>, а определения этих функций лежат уже в другом о-файле в заранее известном месте. задача линковщика - найти места определения функций и подставить их в места вызова
можно посмотреть на стадии
g++ -E 1_1.cpp > output.cpp - после препроцессинга
g++ -S 1_1.cpp - получаем ассемблерный код
g++ -c 1_1.cpp - получаем объектный файл 
как g++ понимает че ему делать - по расширению файла.
godbolt.org - вводим код и получаем какой ассемблерный код соответствует программе
можно менять компиляторы даже

Санитайзеры - специальная программа, позволяющая отлавливать UB
как скомпилировать с санитайзером
g++ -fsanitaze=address 1_6_ce_ub.cpp
теперь мы увидим проблему в рантайме
g++ -fsanitaze=address -g 1_6_ce_ub.cpp - доп. инфа, напишет даже строчку
есть ещё fsanitaze=undefined - переполнение интов
fsanitize=leak - утечки памяти
[[3.1 Basics of OOP, Classes and structures, encapsulation]]
