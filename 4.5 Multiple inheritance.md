как работает:

`class Son: public Mom, public Dad`

как размещается в памяти?

мама, папа, сын (будет по 4, если инты кладём, кладутся в порядке объявления)

если в функцию отдаём сына, то каст разрешён к папе (а вот это интересно, ведь как бы в памяти сначала лежит мама, поэтому он должен сдвинуть указатель от начала к папе, то есть на 4 вправо)

если у мамы и папы есть 2 метода с одинаковыми названиями, то будет перегрузка между ними (а потом CE)

Granny -> Mom Dad -> Son (**проблема ромбовидного наследования**).

Допустим у каждого есть int, тогда он в памяти будет занимать не 16, а 20 байт, потому что для каждого мамы и папы будет отдельный объект (в памяти лежат - бабушка, мать, бабушка, отец и сын)

Тогда g (метод бабки) - будет CE 
аналогично нельзя кастить к бабушке сына, потому что (CE - ambigious cast) - неоднозначный каст

как чинить? сначала к маме, потом к бабушке
если у бабушки есть какой-то метод, то аналогично нельзя вызвать f

Granny -> Dad
и мы от Dad и от Granny
Вот тут уже никак не можем обратиться к бабушкам в принципе (ошибка - innaccesible base class)

Mom (с методом f) Dad (тоже с методом f)

возьмём указатель на метод мамы:
`void (Mom::*p)() = &Mom::f`
и вызовем через сына
`(s.*p)()`
то всё будет окей

но с отцом всё будет уже плохо
Адрес функции остаётся, но вы вызываетесь от объекта сына
укзатель на метод хранит адрес функции и сдвиг (поэтому будет 16)

[[4.6 Virtual inheritance]]
