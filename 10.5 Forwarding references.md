в чём проблема

есть emplace back - не умеет мувать, если мы будем передавать `const struct&`

То есть нам нужно в construct передать все ссылки и сохранить их

и вот трабл в том, что мы не можем сделать тупо 2 перегрузки от `const s&` и от `s&&`

нам нужно $2^n$ перегрузок в таком случае

здесь нам нужен новый вид ссылок и новую функцию

то есть если нам отдали 5 [[10.3 rvalue, lvalue|rvalue]] и 5 [[10.3 rvalue, lvalue|lvalue]], то мы хотим их так и оставлять (то есть сохранять [[10.4 rvalue references|rvalue-ссылки]] и [[10.3 rvalue, lvalue|lvalue]])

```cpp
new (ptr) U(std::forward<Args>(args)…);
```

принимаем `Args&&…`

в язык вводится следующий костыль - если у нас `Args&&` шаблонный, то это универсальная ссылка

универсальная ссылка накидывем амперсанд, если это lvalue

```cpp
template <typename T>
void h(T&& x) {}

void g(T& x) {}

void f(T x) {}

int main() {
	int x = 0;
	g(x); // T = int
	f(x); // T = int
	h(x); // T = int& !!!
	int&& z = std::move(x);
	g(x); // T = int
	f(x); // T = int
	h(x); // T = int&
	h(std::move(x)); // T = int
	h(1); // T = int
}

// если x - lvalue, то мы просто навешиваем ещё амперсанд в функции
// если x - rvalue, то просто ссылка убивается
// а какой тип у x? если rvalue, то ничего + && = &&
// если lvalue, то & + && = &
```

**reference-collapsing**
`& + & = &`
`&& + & = &`
`& + && = &`
`&& + && = &&`
