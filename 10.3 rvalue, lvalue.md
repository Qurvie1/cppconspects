это вообще **категории выражений**, а не типов (виды экспрешенов)

типа `int&&` - это не lvalue или rvalue

`int a = 5;` - lvalue

**lvalue** - идентификатор (любая переменная) (важно - всё это работает для фундаментальных типов, никаких `std::weak_ordering`)

id; (переменная - частный случай экспрешена - всегда лвалью).

присваивающие операции - тоже lvalue;

префиксный инкремент или декремент - lvalue

`*ptr`

`ptr[]`

operator comma if rhs is lvalue

если у тернарного обе части лвалью

function call or cast - это lvalue, если возвращаемый тип это T&

**rvalue**

5, ‘a’, 2.0f (литералы - это рвалью), кроме строкового (”abc”)

`+, -, *, /` и так далее (над фундаментальными типами) - это всё рвалью (то есть операторы все подряд)

постфиксный - rvalue

&a

operator comma if rhs is rvalue

если у тернарного хотя бы один rvalue

function call or cast - это rvalue, если возвращаемый тип это T&&, T

отсюда смысл && - то есть он считается ссылкой, но если вернуться из функции - то это rvalue