```cpp
class Complex {
	Complex(double real) {
		re = real;
	}
};
Complex c(5.0);
Complex c2 = 6.0;
Complex c3{7.0}
```
это всё конструкторы

**ВАЖНО!** 
Инициализировать лучше перед входом в тело конструктора:
```cpp
// Member initializer list
Complex(double real) : re(real) {}
Complex(double re, double im): re(re), im(im) {}
```
в чём сложность, если мы создадим сложный объект и потом сделаем присваивание, то есть мы не делаем типа инициализация 0 и присваивание, а просто сразу инициализируем
(то есть изначально `default -> value`, а так сразу `value`)
и второе очевидно быстрее

в чём смысл объявлять методы в .h, а определять в .cpp? чтоб не было redifintion, когда будем делать много include

в идеале в списке инициализации записывать в порядке ввода переменных

если есть хотя бы один конструктор, то агрегатная инициализация перестаёт работать работает уже конструктор

есть member initializer lists, а есть другой уже (просто `initializer_list`)

типа мы хотим делать

`String s = {'a', 'b', 'c'}`
```cpp
std::initializer_list

String(std::initializer_list<char> list) : arr(new char[list.size()], sz(list.size())) {
	std::copy(list.begin(), list.end(), arr)
	arr[sz] = '\0';
}
```
У `std::initializer_list` есть методы `begin()`, `end()` и `size()`. По сути - это легковесная обёртка над контейнером. Копировать и оперировать нельзя.

если есть хотя бы один конструктор от `inizializer_list` то берётся она, если ни одна не подходит, то берётся `inizializer_list` (если с фигурными скобочками).

explicity declared - явно объявленный, implicity defined - неявно определённый

типа initializer_list помогает нам получить кучу значений типа {a, b, c}

иногда конструктор по умолчанию не работает, например, если поле - ссылка или класс, ещё если поле - константа и мы её не инициализируем

Интересно, что если делать константную ссылку типа r(5), то в классе это работать не будет, поскольку это работает только в функции.

**Деструкторы.**

Функция, которая вызывается перед выходом из области видимости
Обычно нужно типа удаление памяти
Деструкторы вызываются в обратном порядке объявления
Что они делают? Вызывают деструкторы для полей-классов (если - это классы), иначе ничего.
Пока мы в теле деструктора нам ещё доступны поля.

**Конструктор копирования** 
```cpp
String(const String& other): arr(new char[other.cap]), sz(other.sz), cap(other.cap) {
  memcpy(arr, other.arr, sz + 1)
  arr[sz] = '0';
  memmove //корректно работает, даже если пересекаются поля
}
```

делегирующий коструктор - если мы делаем всё то же, что и в другом конструкторе + что-то ещё, то можно сказать типа сделай это, а потом ещё 
```cpp
// типа сначала вызывается конструктор от n, а потом мы доделыаем уже всё это в теле
// конструктора
String(size_t n, char c): String(n) { //это значит сделай всё то же самое, а потом доделай 
memcpy(...)
}
```
`String() = delete` - запрет вызова функции
[[3.4 Rule of three]]
