как выделяется массив?
int a[5] = {1, 2, 3, 4, 5};
Можно обращаться по индексу, массив лежит на стеке (то есть он ограничен), если приписать статик, то всё будет хорошо. [[2.2 Kind of memory]]
Массив можно использовать как указатель на инт.
Например (a + 3) - указатель на 3 (это array to pointer conversion)
[[2.1 Pointers]]
Оператор квадратные скобки - это то же самое, что разыменнованый a + 2
Тогда теперь можно спрашивать отрицательные индексы!
Можно даже писать 2[a]
В чём отличие? массивы нельзя инкрементировать, прибавлять, присваивать сайзоф массив - это количество байт всех элементов в массиве
В случае передачи в функцию указателя и массива - это одно и то же самое (то есть похуй как передавать, массив будет низвергнут до указателя).
Динамический массив (массив в динамической памяти)
int* a = new int[100];
нужно писать delete[] a;
интересный факт, когда мы вызываем v[-1], то если мы сдвигаем по сути указатель на массив влево и удаляем элемент, который нам не принадлежит, то есть происходит вообще какой-то треш
Массив переменной длины - a[n]
В чём проблема с переменной длиной? не особо понятно, что будет после массива
То есть на стеке память нам придётся в рантайме выделять в стеке, а это проблема, так как тратится
int* b[5] - массив из 5 указателей на инт.
но int (*c)[5] - указатель на массив из 5 элементов*
что одно и то же
f(int 2 звёздочки**) - одно и то же, что и f(int звёздочка [5])**
а f(int(a*)[5]) - это уже другая функция (это указатель на массив из 5 интов) (то есть у нас не совпали они)
то есть при передаче в функцию массива - он считается за указатель, но при передаче указателя на массив, массив за указатель не считается
сstyle stroke
char* s = "addfadasd" - массив чаров (указатель) неявно к строке в конце добавляется '\0'
(нуль-терминатор)
[[2.4 Pointers to functions]]

